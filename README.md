Тема: Линкер

## Простой пример

1. Объявите в новом файле `main.cpp` функцию которая принимает `int` и возвращает `int` с именем `hello`.   
```cpp
#include <iostream>

// Объявление функции (только прототип)
int hello(int);

int main() {
    int result = hello(5); // Попытка вызвать функцию
    std::cout << "Result: " << result << std::endl;
    return 0;
}

```
2. Вызовите функцию в функции `main` и выведите результат в консоль.
3. Попробуйте скомпилировать. Объясните полученную ошибку.
Ошибка линковки (linker error), так как функция hello была объявлена, но её определение отсутствует.
Компилятор успешно скомпилирует код, так как видит, что функция hello объявлена, и проверяет её использование (тип возвращаемого значения и параметры). Однако на этапе линковки (linking) компоновщик не сможет найти тело функции hello для создания исполняемого файла.
4. Определите функцию в файле `main.cpp` (любое валидное тело)
   и попробуйте скомпилировать. (Должно пойти).

```cpp
#include <iostream>

// Объявление и определение функции
int hello(int value) {
    return value * 2; // Простая логика: удваиваем входное значение
}

int main() {
    int result = hello(5); // Вызов функции
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```
Result: 10

Объявление функции без её определения приведёт к ошибке линковки.

## Пример с 2 файлами

1. Объявите в новом файле `main.cpp` функцию которая принимает `int` и возвращает `int` с именем `hello`.
2. Вызовите функцию в функции `main` и выведите результат в консоль.
```cpp
#include <iostream>

// Объявление функции (прототип)
int hello(int);

int main() {
    int result = hello(5); // Вызов функции
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```
3. Объявите в новом файле `f.cpp` функцию которая принимает `int` и возвращает `int` с именем `hello`.
```cpp
// Объявление функции (ещё одно)
int hello(int);
```
4. Попробуйте скомпилировать (оба файла разом). Объясните ошибки.
Oшибку линковки, так как функция hello объявлена, но её определение отсутствует. Компоновщик не может найти, где функция реализована.
5. *Определите* фунцию `hello` в файле `f.cpp`, заменив определением ее объявление, и попробуйте скомпилировать. (Должно пойти).
```cpp
int hello(int value) {
    return value * 2; // Простая логика: удваиваем значение
}
```
6. Попробуйте скомпилировать только файл `main.cpp`. Объясните ошибки.
При компиляции только main.cpp, без f.cpp, ошибка линковки, так как hello используется в main.cpp, но её определение отсутствует. Компоновщик не может завершить создание исполняемого файла.
7. Добавьте к определению функции в `f.cpp` модификатор `static`. 
```cpp
static int hello(int value) {
    return value * 2;
}
```
8. Попробуйте скомпилировать. Объясните ошибки.
Функция hello объявлена в main.cpp, но её определение в f.cpp с модификатором static. Модификатор static делает функцию локальной для этого файла. Она не видна в других единицах трансляции (файлах).
9. Перекопируйте определение функции в `main.cpp`, включая `static`, заменив ее объявление.
```cpp
#include <iostream>

// Определение функции с модификатором static
static int hello(int value) {
    return value * 2; // Удваиваем значение
}

int main() {
    int result = hello(5); // Вызов функции
    std::cout << "Result: " << result << std::endl;
    return 0;
}
```
10. Попробуйте скомпилировать. Объясните почему работает. 
Модификатор static делает функцию hello локальной для main.cpp.
Поскольку hello теперь определена прямо в main.cpp, ошибка линковки исчезает, так как её использование и определение находятся в одной единице трансляции.
11. Объясните сколько копий тела функции `hello` скомпилируется в финальный executable
    (можете предположить, что компилятор не уберет неиспользованные копии).
Если функция не static: будет одна копия функции hello, так как определение в f.cpp доступно глобально, и все вызовы ссылаются на неё.
Если функция static в main.cpp и f.cpp: будут две копии функции hello. Каждая единица трансляции создаст свою локальную версию функции.
С static в обоих файлах: 2 копии.
Без static и с одним определением: 1 копия.
