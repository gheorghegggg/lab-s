лаб 1

#include <iostream>

int main() {
    // 1. Объявляем переменную i типа int и инициализируем её на 69
    int i = 69;

    // 2. Определяем переменную number типа int и даём ей значение 72
    int number = 72;

    // 3. Перезаписываем значение i на сумму i и number
    i = i + number;  // i теперь равно 69 + 72 = 141

    // 4. Определяем массив из 3 элементов, инициализируемых на 0
    int arr[3] = {0, 0, 0};

    // 5. Создаём указатель на i
    int* iPointer = &i;

    // 6. Читаем данные по адресу указателя в переменную number
    number = *iPointer;  // number теперь равно 141 (значение i)

    // 7. Вписываем в i через указатель значение 15
    *iPointer = 15;  // i теперь равно 15

    // 8. Меняем адрес в iPointer на адрес первого элемента массива
    iPointer = &arr[0];

    // 9. Перемещаемся на третий элемент массива, используя pointer arithmetic
    iPointer += 2;  // iPointer теперь указывает на третий элемент массива

    // 10. Вписываем в первый элемент массива напрямую, а в третий через iPointer
    arr[0] = 5;     // первый элемент массива теперь равен 5
    *iPointer = 6;  // третий элемент массива теперь равен 6

    // Вывод значений для проверки
    std::cout << "i: " << i << std::endl;
    std::cout << "number: " << number << std::endl;
    std::cout << "Array elements: " << arr[0] << ", " << arr[1] << ", " << arr[2] << std::endl;

    return 0;
}

По шагам:
Создаём переменную i и инициализируем её значением 69.
Создаём переменную number и присваиваем ей значение 72.
Перезаписываем значение i, складывая его с number.
Создаём массив из 3 элементов и инициализируем их нулями.
Создаём указатель на переменную i.
Читаем значение переменной i через указатель и записываем его в number.
Используя указатель, изменяем значение переменной i на 15.
Перенаправляем указатель на первый элемент массива.
При помощи арифметики указателей перемещаемся на третий элемент массива.
Записываем в первый элемент массива значение 5 напрямую, а в третий — через указатель значение 6.
Результат:
Переменная i будет равна 15.
Переменная number будет равна 141 (первоначальное значение i перед изменением).
Массив будет содержать значения: [5, 0, 6].

ЛАБ 2

#include <string.h>
#include <iostream>

// Структура, содержащая два целых числа
struct TwoInts
{
    int a;
    int b;
};

// Структура, содержащая массив и указатель на целое число
struct StructWithArray
{
    int arr[4];      // массив на 4 элемента
    int* someNumber; // указатель на целое число
};

int main()
{
    // Создаем структуру и инициализируем её нулями
    TwoInts i2 = { };
    i2.a = 5; // присваиваем 5 в поле 'a'
    i2.b = 7; // присваиваем 7 в поле 'b'

    // Выводим значения полей структуры i2
    std::cout << i2.a << std::endl; // вывод: 5
    std::cout << i2.b << std::endl; // вывод: 7
    
    // Создаем структуру с массивом и инициализируем её
    StructWithArray s = { };
    s.arr[0] = 10; // первый элемент массива 'arr' структуры 's' получает значение 10

    // Создаем другую структуру с массивом
    StructWithArray s1 = { };
    s1.arr[0] = 15; // первый элемент массива 'arr' структуры 's1' получает значение 15

    // Указатель на структуру 's'
    StructWithArray* sPointer = &s;
    sPointer->arr[0] = 20; // через указатель меняем первый элемент массива структуры 's' на 20

    // Выводим первый элемент массива 'arr' структуры 's'
    std::cout << s.arr[0] << std::endl; // вывод: 20
    s.arr[0] = 25; // изменяем первый элемент массива 'arr' на 25
    std::cout << s.arr[0] << std::endl; // вывод: 25
    sPointer->arr[0] = 30; // через указатель снова меняем значение первого элемента массива на 30
    std::cout << s.arr[0] << std::endl; // вывод: 30

    // Перенаправляем указатель на структуру 's1'
    sPointer = &s1;
    sPointer->arr[0] = 35; // меняем первый элемент массива структуры 's1' на 35
    std::cout << s.arr[0] << std::endl; // вывод: 30 (значение массива 's' не изменилось)
    std::cout << s1.arr[0] << std::endl; // вывод: 35 (мы изменили первый элемент массива 's1')

    // Создаем массив из двух структур
    StructWithArray structArray[2] = { };
    structArray[0].arr[3] = 77; // устанавливаем значение четвертого элемента массива первой структуры равным 77
    structArray[1].someNumber = &structArray[0].arr[3]; // указываем, что указатель второй структуры ссылается на этот элемент массива

    // Указатель на структуру 's'
    sPointer = &s;
    // Указатель на четвертый элемент массива структуры 's'
    int* pointer = &sPointer->arr[3];
    s.arr[3] = 72; // меняем значение четвертого элемента массива 's' на 72
    std::cout << *pointer; // вывод: 72 (указатель 'pointer' ссылается на этот элемент массива)

    // Очищаем память структуры 'memory'
    StructWithArray memory;
    memset(&memory, 0, sizeof(StructWithArray)); // заполняем память нулями
    return 0;
}

Переменная i2:

В структуре TwoInts хранятся два целых числа. В начале программа записывает 5 в поле a и 7 в поле b. Вывод программы:
5
7

Переменные s и s1:

Обе структуры StructWithArray имеют массив из 4 элементов. Изначально они инициализированы нулями.
Сначала через указатель изменяется первый элемент массива s на 20, затем этот элемент несколько раз перезаписывается (сначала 25, затем 30). В итоге массив выглядит так:
s.arr = {30, 0, 0, 0}

Изменение s1:

Когда указатель sPointer перенаправляется на s1, программа изменяет первый элемент массива s1 на 35. Это не влияет на массив s, что можно увидеть из вывода:
30
35

Массив структур structArray:

В четвертом элементе массива первой структуры массива structArray записывается значение 77:
css
structArray[0].arr = {0, 0, 0, 77}
Указатель второй структуры (someNumber) теперь ссылается на этот элемент:
css
structArray[1].someNumber -> structArray[0].arr[3] = 77

Указатели и изменение памяти:

После того, как указатель pointer ссылается на четвертый элемент массива s, значение этого элемента изменяется на 72. Теперь при выводе значения через указатель мы получаем:
72

Обнуление структуры memory:

В конце программа вызывает memset, чтобы занулить память структуры memory.

ЛАБ 3

Типы:
int — целочисленный тип, используемый для представления длины ноги (length в Leg) и силы руки (power в Arm).
Leg — структура, содержащая одно поле int length.
Arm — структура, содержащая одно поле int power.
std::array<Leg, 2> — это статический массив, состоящий из двух объектов типа Leg. Этот тип используется для поля legs структуры Person.
Arm[2] — массив из двух объектов типа Arm. Используется для поля arms в структуре Person.
Person — структура, содержащая массивы объектов типа Leg и Arm.
Объекты:
Person person — объект типа Person, созданный в функции main. Этот объект содержит:
legs — объект типа std::array<Leg, 2>, содержащий два объекта типа Leg.
person.legs[0] — объект типа Leg, содержащий поле int length.
person.legs[1] — объект типа Leg, содержащий поле int length.
arms — массив из двух объектов типа Arm.
person.arms[0] — объект типа Arm, содержащий поле int power.
person.arms[1] — объект типа Arm, содержащий поле int power.
Иерархия объектов:
Person person состоит из:
Leg legs[2] (массив из двух объектов Leg):
каждый объект Leg содержит поле int length.
Arm arms[2] (массив из двух объектов Arm):
каждый объект Arm содержит поле int power.
Итак, все типы:

Примитивный тип: int
Пользовательские типы: Leg, Arm, Person
Шаблонный тип: std::array<Leg, 2>
Все объекты:

person
person.legs[0], person.legs[1]
person.arms[0], person.arms[1]

ЛАБ 4

#include <iostream>

int main()
{
    int number = 10;

    // Проверка на то, является ли число 5
    if (number == 5)
    {
        std::cout << "The number is 5" << std::endl;
        return 0; // Early return, если число 5
    }

    // Число не равно 5
    std::cout << "The number is not 5" << std::endl;

    // Проверка на делимость на 2
    if (number % 2 == 1)
    {
        std::cout << "The number is not divisible by 2" << std::endl;
        return 0; // Early return, если число не делится на 2
    }

    // Число делится на 2
    std::cout << "The number is divisible by 2" << std::endl;

    // Проверка на равенство 6
    if (number == 6)
    {
        std::cout << "The number is 6" << std::endl;
        return 0;
    }

    return 0;
}

Объяснение:
Первое условие проверяет, равно ли число 5. Если да, то программа выводит сообщение и немедленно завершает выполнение (return).
Если число не равно 5, выполняется следующий блок кода, который проверяет делимость числа на 2.
Если число не делится на 2, выводится соответствующее сообщение и выполнение прекращается.
Если число делится на 2, проверяется, равно ли оно 6. Если да, выводится сообщение, и программа завершает работу.
Вложенность if-else сведена к минимуму, улучшена читаемость и поддерживаемость кода.

#include <iostream>

// Создаем структуру для хранения количества фруктов
struct FruitCounts
{
    int apples;
    int pears;
    int oranges;
};

int main()
{
    // Создаем переменную типа FruitCounts для хранения количества фруктов
    FruitCounts fruitCounts;

    // Ввод данных
    std::cout << "Apples: ";
    std::cin >> fruitCounts.apples;

    std::cout << "Pears: ";
    std::cin >> fruitCounts.pears;

    std::cout << "Oranges: ";
    std::cin >> fruitCounts.oranges;

    // Создаем блок для временных переменных подусловий
    {
        // Временные переменные для каждого подусловия
        bool moreThanFiveApples = fruitCounts.apples > 5;
        bool lessThanEightPears = fruitCounts.pears < 8;
        bool orangesTwiceApples = fruitCounts.oranges == 2 * fruitCounts.apples;

        // Временная переменная для итогового условия
        bool overallCondition = moreThanFiveApples && lessThanEightPears && orangesTwiceApples;

        // Проверяем итоговое условие
        if (overallCondition)
        {
            std::cout << "Hello" << std::endl;
        }
    }

    return 0;
}

Объяснение:
Структура FruitCounts содержит три поля: apples, pears и oranges, которые представляют количество соответствующих фруктов.
Ввод значений для фруктов теперь идет в переменные структуры: fruitCounts.apples, fruitCounts.pears, fruitCounts.oranges.
Создается блок для временных переменных:
moreThanFiveApples проверяет, больше ли количество яблок 5.
lessThanEightPears проверяет, меньше ли количество груш 8.
orangesTwiceApples проверяет, в два ли раза больше апельсинов, чем яблок.
Переменная overallCondition хранит результат всех подусловий с использованием логической операции &&.
Если итоговое условие истинно, выводится "Hello".
Этот код теперь структурирован, легко читается и использует структуру для организации данных.

#include <span>
#include <cassert>

void product(std::span<int> inputOutput, std::span<int> coefficients)
{
    // Убедимся, что длины массивов совпадают
    assert(inputOutput.size() == coefficients.size());

    // Индекс для итерации
    size_t i = 0;

    // Бесконечный цикл
    while (true)
    {
        // Если дошли до конца массива, выходим из цикла
        if (i >= inputOutput.size())
        {
            break;
        }

        // Перемножаем элементы массивов
        inputOutput[i] *= coefficients[i];

        // Увеличиваем индекс
        ++i;
    }
}

#include <span>
#include <cassert>

void product(std::span<int> inputOutput, std::span<int> coefficients)
{
    // Убедимся, что длины массивов совпадают
    assert(inputOutput.size() == coefficients.size());

    // Индекс для итерации
    size_t i = 0;

    // Цикл с условием
    while (i < inputOutput.size())
    {
        // Перемножаем элементы массивов
        inputOutput[i] *= coefficients[i];

        // Увеличиваем индекс
        ++i;
    }
}

#include <span>
#include <cassert>

void product(std::span<int> inputOutput, std::span<int> coefficients)
{
    // Убедимся, что длины массивов совпадают
    assert(inputOutput.size() == coefficients.size());

    // Цикл for
    for (size_t i = 0; i < inputOutput.size(); ++i)
    {
        // Перемножаем элементы массивов
        inputOutput[i] *= coefficients[i];
    }
}

Описание:
В каждом варианте используется assert, чтобы убедиться, что массивы одинаковой длины.
В первой версии используется бесконечный цикл while (true) с явным выходом через break.
Вторая версия использует цикл while с условием продолжения итерации до конца массива.
В третьей версии используется стандартный цикл for, который также итерируется до конца массива.

ЛАБ 5

#include <string_view>
#include <cassert>

// Функция для подсчета символов '1' в строке
size_t countOnes(std::string_view str)
{
    size_t count = 0;
    
    // Цикл по каждому символу строки
    for (char c : str)
    {
        if (c == '1')
        {
            ++count; // Увеличиваем счетчик, если символ '1'
        }
    }
    
    return count; // Возвращаем количество '1'
}

// Функция с тестами
void runTests()
{
    // Тест: ни одной '1'
    assert(countOnes("0000") == 0);

    // Тест: несколько '1'
    assert(countOnes("001100") == 2);

    // Тест: все символы '1'
    assert(countOnes("1111") == 4);

    // Тест: строка пустая
    assert(countOnes("") == 0);

    // Тест: строка содержит только один символ '1'
    assert(countOnes("1") == 1);

    // Тест: строка содержит только один символ '0'
    assert(countOnes("0") == 0);
}

int main()
{
    // Запуск тестов
    runTests();
    return 0;
}

Описание:
Функция countOnes:

Принимает строку в виде std::string_view, что позволяет работать с любыми строковыми типами, не копируя данные.
Использует цикл for, который проходит по каждому символу строки.
Считает символы '1' с помощью простого счетчика count.
Функция runTests:

Содержит тесты, которые проверяют различные сценарии:
Строка без '1'.
Строка с несколькими '1'.
Строка, полностью состоящая из '1'.
Пустая строка.
Строки, содержащие один символ ('1' или '0').
Тесты выполняются с помощью assert, который проверяет, что результат функции совпадает с ожидаемым значением.

Тесты покроют все основные сценарии работы функции и помогут убедиться, что она работает корректно.

#include <string_view>
#include <cassert>

// Функция, которая находит и возвращает "второе слово" в строке
std::string_view secondWord(std::string_view str)
{
    // Найдем первый пробел
    size_t firstSpace = str.find(' ');
    
    // Если пробела нет, или строка пуста
    if (firstSpace == std::string_view::npos || firstSpace + 1 == str.size())
    {
        return ""; // Возвращаем пустую строку
    }
    
    // Найдем следующий непробельный символ после первого пробела
    size_t firstNonSpace = str.find_first_not_of(' ', firstSpace + 1);

    // Если после первого пробела нет непробельных символов
    if (firstNonSpace == std::string_view::npos)
    {
        return ""; // Возвращаем пустую строку
    }

    // Найдем второй пробел после найденного слова
    size_t secondSpace = str.find(' ', firstNonSpace);

    // Если второго пробела нет, возвращаем оставшуюся часть строки
    if (secondSpace == std::string_view::npos)
    {
        return str.substr(firstNonSpace);
    }

    // Возвращаем кусок строки между первым и вторым пробелами
    return str.substr(firstNonSpace, secondSpace - firstNonSpace);
}

// Тесты для функции secondWord
void runTests()
{
    // Пример: "Hello world" => "world"
    assert(secondWord("Hello world") == "world");

    // Пример: "Hello my dear" => "my"
    assert(secondWord("Hello my dear") == "my");

    // Пример: пустая строка => ""
    assert(secondWord("") == "");

    // Пример: строка, состоящая из пробела => ""
    assert(secondWord(" ") == "");

    // Пример: строка с одним словом между пробелами => "a"
    assert(secondWord(" a ") == "a");

    // Пример: строка с одним словом и двумя пробелами => ""
    assert(secondWord("a  ") == "");

    // Пример: строка с двумя словами и двумя пробелами между ними => ""
    assert(secondWord("a  b") == "");
}

int main()
{
    // Запуск тестов
    runTests();
    return 0;
}


Для решения задачи напишем функцию secondWord, которая будет искать первый пробел в строке, затем начинать поиск второго пробела и возвращать часть строки между ними. Если второго пробела нет, возвращаем остальную часть строки.

Реализация функции secondWord и тестов:
cpp
Копировать код
#include <string_view>
#include <cassert>

// Функция, которая находит и возвращает "второе слово" в строке
std::string_view secondWord(std::string_view str)
{
    // Найдем первый пробел
    size_t firstSpace = str.find(' ');
    
    // Если пробела нет, или строка пуста
    if (firstSpace == std::string_view::npos || firstSpace + 1 == str.size())
    {
        return ""; // Возвращаем пустую строку
    }
    
    // Найдем следующий непробельный символ после первого пробела
    size_t firstNonSpace = str.find_first_not_of(' ', firstSpace + 1);

    // Если после первого пробела нет непробельных символов
    if (firstNonSpace == std::string_view::npos)
    {
        return ""; // Возвращаем пустую строку
    }

    // Найдем второй пробел после найденного слова
    size_t secondSpace = str.find(' ', firstNonSpace);

    // Если второго пробела нет, возвращаем оставшуюся часть строки
    if (secondSpace == std::string_view::npos)
    {
        return str.substr(firstNonSpace);
    }

    // Возвращаем кусок строки между первым и вторым пробелами
    return str.substr(firstNonSpace, secondSpace - firstNonSpace);
}

// Тесты для функции secondWord
void runTests()
{
    // Пример: "Hello world" => "world"
    assert(secondWord("Hello world") == "world");

    // Пример: "Hello my dear" => "my"
    assert(secondWord("Hello my dear") == "my");

    // Пример: пустая строка => ""
    assert(secondWord("") == "");

    // Пример: строка, состоящая из пробела => ""
    assert(secondWord(" ") == "");

    // Пример: строка с одним словом между пробелами => "a"
    assert(secondWord(" a ") == "a");

    // Пример: строка с одним словом и двумя пробелами => ""
    assert(secondWord("a  ") == "");

    // Пример: строка с двумя словами и двумя пробелами между ними => ""
    assert(secondWord("a  b") == "");
}

int main()
{
    // Запуск тестов
    runTests();
    return 0;
}
Описание:
Функция secondWord:

find ищет первый пробел в строке.
Если пробела нет или строка пустая, возвращаем пустую строку.
Используем find_first_not_of для поиска первого символа, который не является пробелом, после первого пробела.
Если после первого пробела нет непробельных символов, возвращаем пустую строку.
Ищем второй пробел. Если второго пробела нет, возвращаем всю оставшуюся строку.
Если второй пробел найден, возвращаем часть строки между первым непробельным символом и вторым пробелом.
Тесты:

Описаны тесты для всех указанных случаев: с пробелами, без пробелов, с одним словом и с двумя пробелами подряд.
Этот подход покрывает все описанные сценарии, включая случаи с множественными пробелами и пустыми строками.